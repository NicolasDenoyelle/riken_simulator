FUJITSU CONFIDENTIAL
Fujitsu C/C++ Version 1.2.0   Mon Mar 25 17:24:12 2019
Compilation information
  Current directory : /home/odajima/bug_report/RIST/issue310
  Source file       : issue310.cpp
(line-no.)(optimize)
        1             #include <stdio.h>
        2             #include <omp.h>
        3             
        4             #define DIM 3
        5             typedef float real;
        6             typedef real    rvec[DIM];
        7             
        8             template<int Parm0, int Parm1>
        9             static void 
       10             sub0(int                        start,
       11                  int                        nrend,
       12                  real                       dt,
       13                  const rvec * __restrict    p3,
       14                  const real *               lambda,
       15                  const rvec * __restrict    x,
       16                  rvec       * __restrict    xprime,
       17                  rvec       * __restrict    v,
       18                  const rvec * __restrict    f)
       19             {
       20                 real lambdaGroup;
       21             	if(Parm0 == 0 ) {
       22                 	lambdaGroup = lambda[0];
       23             	}
       24             
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: 16)
                       <<<    PREFETCH(SOFT) : 4
                       <<<     SEQUENTIAL : 4
                       <<<      (unknown): 4
                       <<<    SPILLS :
                       <<<      GENERAL   : SPILL 0  FILL 2
                       <<<      SIMD&FP   : SPILL 0  FILL 0
                       <<<      SCALABLE  : SPILL 0  FILL 0
                       <<<      PREDICATE : SPILL 0  FILL 0
                       <<< Loop-information  End >>>
       25          v      for (int a = start; a < nrend; a++)
       26          v      {
       27          v  		if(Parm0 == 1) {
       28             			lambdaGroup = lambda[a];
       29             		}
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information  End >>>
       30         fv          for (int d = 0; d < DIM; d++)
       31         fv          {
       32         fv              real vNew = lambdaGroup*v[a][d] + f[a][d]*p3[a][d]*dt;
       33         fv  			if(Parm1 == 1) {
       34         f   				vNew = f[a][d]*lambdaGroup*dt;
       35         f   			}
       36         fv              v[a][d]      = vNew;
       37         fv              xprime[a][d] = x[a][d] + vNew*dt;
       38         fv          }
       39          v      }
       40             }
       41             
       42             void
       43             sub1(int nth, int th, int homenr, int *start, int *nrend)
       44             {
       45             	*start = homenr/nth * th;
       46             	if(th == nth - 1) *nrend = homenr;
       47             	else *nrend = homenr/nth * (th + 1);
       48             }
       49             
       50             void 
       51             sub2(int				homenr,
       52             	 real				dt,
       53             	 const rvec * 		p3,
       54             	 const real *		lambda,
       55             	 const rvec 		*x,
       56             	 rvec       		*xprime,
       57             	 rvec       		*v,
       58             	 const rvec 		*f)
       59             {
       60             
       61                 int nth = omp_get_max_threads();
       62             
       63             #pragma omp parallel for num_threads(nth) schedule(static)
       64   p             for (int th = 0; th < nth; th++)
       65   p      s      {
       66   p      s          int start, nrend;
       67   pi     s          sub1(nth, th, homenr, &start, &nrend);
       68   p      s      	sub0<0,0>
       69                     (start, nrend, dt, p3, lambda, x, xprime, v, f);
       70   p      s      }
       71             }
       72             
       73             #define HOMENR 12000
       74             
       75             real p3[HOMENR][DIM];
       76             real x[HOMENR][DIM];
       77             real xprime[HOMENR][DIM];
       78             real v[HOMENR][DIM];
       79             real f[HOMENR][DIM];
       80             
       81             int 
       82             main(int argc, char *argv[])
       83             {
       84             	int  homenr = HOMENR;
       85                 real dt     = 0.005;
       86             	real lambda[1];
       87             	lambda[0] = 0.001;
       88             
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: 16)
                       <<<    PREFETCH(HARD) Expected by compiler :
                       <<<      f, v, xprime, x, p3, (unknown)
                       <<< Loop-information  End >>>
       89          v  	for(int i = 0; i < HOMENR; i++) {
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SPLIT
                       <<<    FULL UNROLLING
                       <<< Loop-information  End >>>
       90         fv  		for(int j = 0; j < DIM; j++) {
       91         fv  			p3[i][j] = (float)(DIM*i+j);
       92         fv  			x[i][j] = (float)(DIM*i+j+1);
       93         fv  			xprime[i][j] = (float)(DIM*i+j+2);
       94         fv  			v[i][j] = (float)(DIM*i+j+3);
       95         fv  			f[i][j] = (float)(DIM*i+j+4);
       96         fv  		}
       97             	}
       98             
       99             	sub2(homenr, dt, p3, lambda, x, xprime, v, f);
      100             
      101             	int errcount = 0;
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    PREFETCH(HARD) Expected by compiler :
                       <<<      xprime, (unknown)
                       <<<    SPILLS :
                       <<<      GENERAL   : SPILL 6  FILL 8
                       <<<      SIMD&FP   : SPILL 0  FILL 0
                       <<<      SCALABLE  : SPILL 0  FILL 0
                       <<<      PREDICATE : SPILL 0  FILL 0
                       <<< Loop-information  End >>>
      102             	for(int i = 0; i < HOMENR; i++) {
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information  End >>>
      103         f   		for(int j = 0; j < DIM; j++) {
      104         f   			if(xprime[i][j] == (float)(DIM*i+j+2)) {
      105         f   				if(errcount < 100) {
      106         f   					printf("%3d xprime[%d][%d]:%g remain unchanged.\n",
      107             					errcount, i, j, xprime[i][j]);
      108         f   				} else if(errcount == 100) {
      109         f   					printf("entering silent mode...\n");
      110         f   				}
      111         f   				errcount++;
      112         f   			}
      113         f   			if(v[i][j] == (float)(DIM*i+j+3)) {
      114         f   				if(errcount < 100) {
      115         f   					printf("%3d v[%d][%d]:%g remain unchanged.\n",
      116             					errcount, i, j, v[i][j]);
      117         f   				} else if(errcount == 100) {
      118         f   					printf("entering silent mode...\n");
      119         f   				}
      120         f   				errcount++;
      121         f   			}
      122         f   		}
      123             	}
      124             	if(errcount) {
      125             		printf("FAILED. Total %d data unchanged\n", errcount);
      126             	} else {
      127             		printf("PASSED. All data changed.\n");
      128             	}
      129             	return 0;
      130             }
Total prefetch num: 4
Optimization messages
  jwd6001s-i  "issue310.cpp", line 25: SIMD conversion is applied to this loop with the loop variable 'a'.
  jwd8222o-i  "issue310.cpp", line 25: The prefetch instructions were generated because the number of prefetch required in this loop is greater than the allowable number of hardware-prefetch.
  jwd8662o-i  "issue310.cpp", line 25: This loop is not software pipelined because no schedule is obtained.
  jwd8203o-i  "issue310.cpp", line 30: Loop full unrolling is applied to this loop.
  jwd6142s-i  "issue310.cpp", line 64: SIMD conversion is not applied to this loop because the iteration count is uncertainty.
  jwd8664o-i  "issue310.cpp", line 64: This loop cannot be software pipelined because the loop contains an instruction, such as function call, which is not supported by software pipelining.
  jwd8101o-i  "issue310.cpp", line 67: Inline expansion is applied to the user defined function '_Z4sub1iiiPiS_'.
  jwd6001s-i  "issue310.cpp", line 89: SIMD conversion is applied to this loop with the loop variable 'i'.
  jwd8665o-i  "issue310.cpp", line 89: This loop cannot be software pipelined because of shortage of integer registers.
  jwd8203o-i  "issue310.cpp", line 90: Loop full unrolling is applied to this loop.
  jwd8664o-i  "issue310.cpp", line 102: This loop cannot be software pipelined because the loop contains an instruction, such as function call, which is not supported by software pipelining.
  jwd8203o-i  "issue310.cpp", line 103: Loop full unrolling is applied to this loop.
Statistics information
  Option information
    Command line options : -Kfast,openmp -Nlst=t -Koptmsg=2 -S
    Effective options    : -g0 -mt -Qy -std=gnu++03 -x- -x=quick -O3 -Knoalias_const
                           -Kalign_loops -Kassume=noshortloop -Kassume=nomemory_bandwidth
                           -Kassume=notime_saving_compilation -Kcmodel=small -Keval
                           -Keval_noconcurrent -Kfast_matmul -Knofed -Knofenv_access
                           -Kfp_contract -Kfp_relaxed -Kfsimple -Kfz -Khpctag -Kilfunc=loop
                           -Knolargepage -Klib -Kloop_blocking -Kloop_fission
                           -Kloop_nofission_if -Kloop_fusion -Kloop_interchange
                           -Kloop_part_simd -Kloop_noversioning -Klooptype=f -Knolto
                           -Knomemalias -Kmfunc=1 -Knontst -Knoocl -Komitfp -Kopenmp
                           -Kopenmp_noassume_norecurrence
                           -Kopenmp_nocollapse_except_innermost -Kopenmp_noordered_reduction
                           -Knoopenmp_simd -Knooptlib_string -Koptmsg=2
                           -Knopc_relative_literal_loads -Knoparallel
                           -Kparallel_nofp_precision -Knopreex -Kprefetch_cache_level=all
                           -Kprefetch_noconditional -Kprefetch_noindirect -Kprefetch_noinfer
                           -Kprefetch_sequential=auto -Kprefetch_nostride -Kprefetch_strong
                           -Kprefetch_strong_L2 -Krdconv -Kremove_inlinefunction -Knorestp
                           -Ksch_post_ra -Ksch_pre_ra -Ksibling_calls -Ksimd=auto
                           -Ksimd_packed_promotion -Ksimd_reduction_product
                           -Ksimd_reg_size=512 -Knostrict_aliasing -Knostriping -KA64FX
                           -KARMV8_3_A -KSVE -Knostl_fast_new -Kswp -Kswp_freg_rate=100
                           -Kswp_ireg_rate=100 -Kswp_preg_rate=100 -Kunroll
                           -Knounroll_and_jam -Knozfill -Ncancel_overtime_compilation
                           -Nnocoverage -Nexceptions -Nnofjcex -Nnohook_func -Nnohook_time
                           -Nfjomplib -Nline -Nlst=p -Nlst=t -Nquickdbg=noheapchk
                           -Nquickdbg=nosubchk -NRnotrap -Nnoreordered_variable_stack
                           -Nrt_notune -Nsetvalue=noheap -Nsetvalue=nostack
                           -Nsetvalue=noscalar -Nsetvalue=noarray -Nsetvalue=nostruct -Nsrc
                           -Nsta -Nstl=libc++
